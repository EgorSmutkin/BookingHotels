@model IEnumerable<BookingHotels.Web.Models.RoomViewModel>
@{
ViewBag.Title = "Rooms";
}
@* Content *@
<div class="col-sm-8">
    <h2>@ViewBag.Title</h2>
    <hr />
    <h3> We have
        <span data-bind="text: koRooms().length"></span>
        rooms:
    </h3>
    @* Knockout template: *@
    <div data-bind="template: { name: 'koRoomDisplayTemplate', foreach: koRoomsFiltered }"></div>

    <script type="text/html" id="koRoomDisplayTemplate">
        <div class="card col-md-3 text-center">
            <img class="card-img-top" src="/Content/Images/room.png" width="100" height="100">
            <h4 class="card-title">
                <span data-bind="text: RoomType"></span>
            </h4>
            <p class="card-text">
                This room is in
                <a href="#" data-bind="click: $parent.hotelDetails">
                    <span data-bind="text: Hotel.HotelName"></span>
                </a>
            </p>
            <a href="#" data-bind="click: $parent.details">
                <span class="btn btn-primary" data-bind="text: $parent.bookThisRoom(RoomPrice)"></span>
            </a>
        </div>
    </script>
</div>

@* Sidebar *@
<div class="col-sm-4 text-center">
     <h2>Filters</h2>
     <hr/>
     <div class="row">
         <div class="col-sm-5">
             Max room price
           </div>
         <div class="col-sm-7">
             <input 
             type="number"
             class="form-control" 
            data-bind="textInput: maxRoomPrice">
         </div>$
     </div>
     <br/>
     <div class="row">
         <div class="col-sm-5">
             Room type
         </div>
         <div class="col-sm-7">
             <select 
                 class="selectpicker"
                 data-selected-text-format="count > 3"
                 multiple
                 data-bind="selectedOptions: selectedRoomTypes, options: koRoomTypes">
             </select>
         </div>
     </div>
     <br/>
     <div class="row">
         <div class="col-lg-12">
             <label for="filterSortPrice">Sort by price</label>
             <input type="radio"
                    data-bind="checked: sorting"
                    value="priceSort"
                    id="filterSortPrice" />
         </div>
     </div>
    <div class="row">
        <div class="col-lg-12">
            <label for="filterSortType">Sort by room type</label>
            <input type="radio"
                   data-bind="checked: sorting"
                   value="roomTypeSort"
                   id="filterSortType" />
        </div>
    </div>
    <br/>
    <div class="row">
        <div class="col-lg-6">
            <label for="startDate">Start date</label>
            <input type="date"
                   data-bind="textInput: startDate"
                   id="startDate" />
        </div>
        <div class="col-lg-6">
            <label for="endDate">End date</label>
            <input type="date"
                   data-bind="textInput: endDate"
                   id="endDate" />
        </div>
    </div>
     <hr />
 </div>

<script type="text/javascript">
    // Using Json.NET to JSON encode server-side Model directly in view
    var JsonRooms = JSON.parse("@Html.Raw(HttpUtility.JavaScriptStringEncode(
        Newtonsoft.Json.JsonConvert.SerializeObject(
        Model,
        Newtonsoft.Json.Formatting.None,
        new Newtonsoft.Json.JsonSerializerSettings {
        ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore }
        )))");
    console.log(JsonRooms);

    var JsonBookings = JSON.parse("@Html.Raw(HttpUtility.JavaScriptStringEncode(
        Newtonsoft.Json.JsonConvert.SerializeObject(
        ViewBag.bookings,
        Newtonsoft.Json.Formatting.None,
        new Newtonsoft.Json.JsonSerializerSettings {
        ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore }
        )))");
    console.log(JsonBookings);


    function filter(arr, criteria) {
        return arr.filter(function(obj) {
            return Object.keys(criteria).every(function(c) {
                return obj[c] == criteria[c];
            });
        });
    }

    var JsonRoomTypes = JSON.parse("@Html.Raw(HttpUtility.JavaScriptStringEncode(
        Newtonsoft.Json.JsonConvert.SerializeObject(
        Enum.GetNames(typeof(BookingHotels.Domain.Enums.RoomType))
        )))");
    console.log(JsonRoomTypes);

    /*
    $.each(JsonBookings, function (index, value) {
        console.log('My array has at position ' + index + ', this value: ' + value);
    });
    */

    @* Knockout View Model *@
    var koRoomViewModel =
    {
        // All rooms in array of objects
        koRooms: ko.observableArray(JsonRooms),
        koRoomTypes: ko.observableArray(JsonRoomTypes),
        selectedRoomTypes: ko.observableArray(JsonRoomTypes),
        maxRoomPrice: ko.observable(),
        startDate: ko.observable(),
        endDate: ko.observable(),
        bookings: ko.observableArray(JsonBookings),
        sorting: ko.observable(),
        // Knockout supplies the current model value as the first parameter
        details : function (room) {
            window.location.href = "/room/details/" + room.Id;
        },
        hotelDetails : function (room) {
            window.location.href = "/hotel/details/" + room.HotelId;
        },
        bookThisRoom : function (price) {
            return "Book for " + price + " $";
        },

        sortTypes: {
            // Room sort by price
            'priceSort': function (left, right) {
                return left.RoomPrice === right.RoomPrice ? 0 : (left.RoomPrice < right.RoomPrice ? -1 : 1)
            },
            'roomTypeSort': function (left, right) {
                return left.RoomType === right.RoomType ? 0 : (left.RoomType < right.RoomType ? -1 : 1)
            }
        }, 

        sortProcesssing: function (sortType) {
            sortType = sortType || this.sorting();
            if (this.sortTypes[sortType]) {
                this.koRooms.sort(this.sortTypes[sortType]);
            }
        }
    };

    // Subscribe for sort type changes
    koRoomViewModel.sorting.subscribe(function (sortType) {
        koRoomViewModel.sortProcesssing(sortType);
    });

    koRoomViewModel.koRoomsFiltered = ko.computed(function () {
        var result = koRoomViewModel.koRooms();
        // console.log("maxRoomPrice changed to " + koRoomViewModel.maxRoomPrice());
        // console.log("selectedRoomTypes  changed to " + koRoomViewModel.selectedRoomTypes());

        // console.log("start date filter changed to " + startDateDesired);
        // console.log("end date filter changed to " + endDateDesired);

        // Room Price Filter
        if (koRoomViewModel.maxRoomPrice()) {
            result = ko.utils.arrayFilter(result, function (room) {
                // Return true (to include room)
                // if it's RoomPrice < maxRoomPrice
                return (room.RoomPrice < koRoomViewModel.maxRoomPrice());
            });
        }
        // Room Type Filter
        if (koRoomViewModel.selectedRoomTypes().length) {
            result = ko.utils.arrayFilter(result, function (room) {
                // Return true (to include room)
                // if it's RoomType appears in selectedRoomTypes
                return (-1 != ko.utils.arrayIndexOf(koRoomViewModel.selectedRoomTypes(), room.RoomType));
            });
        }
        // Date filter
        var BookingStartDateDesired = koRoomViewModel.startDate();
        var BookingEndDateDesired = koRoomViewModel.endDate();
        if (BookingStartDateDesired <= BookingEndDateDesired) {
            result = ko.utils.arrayFilter(result, function (room) {
                console.log("===============\n Starting to check room: ");
                console.log(room);
                var bookingsForCurrentRoom = filter(koRoomViewModel.bookings(), { RoomId: room.Id });
                if (bookingsForCurrentRoom.length > 0)
                {
                    // Get all existing booking dates for this room
                    $.each(bookingsForCurrentRoom, function (index, value)
                    {
                        var BookingStartDateExisting = value.BookingStartDate;
                        var BookingEndDateExisting = value.BookingEndDate;
                        // Check if bookings for this room conflict with desired booking
                        if ((BookingStartDateExisting > BookingStartDateDesired && BookingStartDateExisting < BookingEndDateDesired) ||
                            (BookingEndDateExisting > BookingStartDateDesired && BookingEndDateExisting < BookingEndDateDesired))
                        {
                            console.log("This room is occupied from " + BookingStartDateExisting + " to " + BookingEndDateExisting);
                            console.log(room);
                            // Room is occupied for this period, not include
                            return false;
                        }
                        else
                        {
                            console.log("Room is not occupied for this period, include");
                            console.log(room);
                            // Room is not occupied for this period, continue checking
                            return true;
                        }
                    });
                }
                else
                {
                    console.log("This room has no bokings, include");
                    console.log(room);
                    // Current room has no bookings, include
                    return true;
                }
            });
        }
        else
        {
            // Start date must be < end date
        } // Date filter end
    //Return filtered array
    console.log("==============\n Rooms are filtered");
    return result;
    }); // Filters end

    // Apply sort before binding
    koRoomViewModel.sortProcesssing();
    ko.applyBindings(koRoomViewModel);
</script>